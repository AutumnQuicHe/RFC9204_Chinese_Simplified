---
title: "7.3. 内存消耗"
anchor: "7.3_Memory_Consumption"
weight: 7300
rank: "h2"
---

攻击者可以试图令终端耗尽其内存。
QPACK的设计能够限制终端所需的内存量，无论是峰值还是平时。

QPACK通过指定动态表最大尺寸和阻塞流最大数目来限制编码器能够驱使解码器消耗的内存量。
在HTTP/3中，这些值由解码器分别通过设置参数`SETTINGS_QPACK_MAX_TABLE_CAPACITY`和`SETTINGS_QPACK_BLOCKED_STREAMS`（详见[第3.2.3章](#3.2.3_Maximum_Dynamic_Table_Capacity)和[第2.1.2章](#2.1.2_Blocked_Streams)）来控制。
对于动态表尺寸的限制考虑了存储在动态表中的数据尺寸，还为开销额外加上了少量的容许值。
对于阻塞流数目的限制仅仅代表解码器所需的最大内存。
实际的最大内存用量取决于解码去使用多少内存来追踪每条阻塞流。

解码器可以通过为动态表的最大尺寸设置合适的值的方式，限制用于动态表的状态数据所需的内存量。
在HTTP/3中，这是通过为参数`SETTINGS_QPACK_MAX_TABLE_CAPACITY`设置合适的值的方式来做到的。
编码器可以通过选择一个比解码器允许的更小的动态表尺寸，再将它告知解码器的方式来限制状态数据所需的内存量（详见[第4.3.1章](#4.3.1_Set_Dynamic_Table_Capacity)）。

解码器可以通过为阻塞流的最大数目设置合适的值的方式，限制用于阻塞流的状态数据所需的内存量。
在HTTP/3中，这是通过为参数`SETTINGS_QPACK_BLOCKED_STREAMS`设置合适的值的方式来做到的。
有可能被阻塞的流不会在编码器一侧消耗额外的内存。

编码器分配内存来追踪所有未得到确认的字段组中的动态表引用。
实现可以通过只使用它希望追踪的动态表引用数量的方式，直接限制状态数据所需的内存用量；这不需要向解码器发出信号。
不过，限制对动态表的引用会降低压缩效率。

编码器或解码器临时占用的内存量可以通过按序处理字段行的方式限制。
解码器实现不需要在解码某个字段组时维护一份完整的字段行列表。
编码器实现如果使用的是单通算法，那么它不需要在编码某个字段组时维护一份完整的字段行列表。
注意，应用可能不得不出于其他理由维护一份完整的字段行列表；即便QPACK不要求这么做，应用自身的限制也可能强制该行为。

尽管经过协商的动态表尺寸限制占用了大量QPACK实现能够消耗的内存，不过因为流量控制而无法被立即发送出去的数据不会受此限制的影响。
实现应该限制未发送数据的尺寸，特别是在不能自由发送数据的解码流上。
对过量的未发送数据的应对做法包括限制对端打开新流的能力、使得编码流变为只读，或关闭整条连接。
