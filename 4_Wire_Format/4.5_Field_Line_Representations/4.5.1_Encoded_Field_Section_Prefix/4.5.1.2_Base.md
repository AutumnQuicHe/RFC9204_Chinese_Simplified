---
title: "4.5.1.2. 基点"
anchor: "4.5.1.2_Base"
weight: 4512
rank: "h4"
---

基点被用来在动态表中解析引用，[第3.2.5章](#3.2.5_Relative_Indexing)介绍了解析过程。

为了节省空间，基点按照插入计数下限的值被编码为一个信号比特位（[图12](#Figure_12_Encoded_Field_Section)中的`S`）和基点差值。
信号位`0`表示基点大于等于插入计数下限的值；解码器将基点差值与插入计数下限相加，得到基点的值。
信号位`1`表示基点钓鱼插入计数下限；解码器从插入计数下限中减去基点差值，再减去1，得到基点的值。
也就是说：

{{% block_ref
indx="Pseudocode_4_5_1_2_1" %}}

```
if Sign == 0:
   Base = ReqInsertCount + DeltaBase
else:
   Base = ReqInsertCount - DeltaBase - 1
```

{{% /block_ref %}}

单通的编码器在对字段组编码前就要算出基点的值。
如果编码器在编码字段组时会向动态表插入条目并引用它们，那么插入计数下限将大于基点，所以编码出来的差值为负数，信号位被设置为`1`。
如果编码字段组时使用的指称没有引用最近插入动态表的条目，也没有插入任何新条目，那么基点就会大于插入计数下限，所以编码出来的插值为正数，信号位被设置为`0`。

基点的值{{< req_level MUST_NOT >}}为负数。
尽管协议基点为负数时也能正确处理反向索引，但这是不必要且低效的。
如果插入计数下限小于等于基点差值，那么终端{{< req_level MUST >}}将信号位为`1`的字段块视作非法。

在对字段组编码前先对表进行更新的编码器可以将基点的值设置为插入计数下限的值。
在这种情况下，信号位和基点差值均被设置为零。

如果编码字段组时没有引用动态表，那么基点可以是任意值；将基点差值设置为零是最高效的编码方式之一。

举例来说，当插入计数下限为`9`时，解码器接收到了信号位`1`和基点差值`2`。
它会将基点设置为`6`，并为三个条目启用反向索引。
在这个例子中，相对索引`1`指向的是第五个被添加进表的条目；反向索引`1`则指向的是第八个。
